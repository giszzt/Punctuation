<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Punctuation. / 标点</title>
    <!-- 引入核心库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        /* 
         * DESIGN SYSTEM: THE ABSOLUTE
         * Philosophy: Reduction content-first, motion-driven.
         */

        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&family=Noto+Serif+SC:wght@300;500;700&display=swap');

        :root {
            /* 
             * PALETTE
             * We don't use "Blue" or "Red". We use Light and Absence.
             */
            --bg: #FAFAFA;
            --surface: #FFFFFF;
            --ink: #111111;
            --ink-secondary: #666666;
            --ink-tertiary: #AAAAAA;

            --accent: #111111;
            /* Brutalist Black */
            --accent-soft: rgba(0, 0, 0, 0.04);

            --line: #EAEAEA;
            --radius-sm: 8px;
            --radius-lg: 24px;

            --font-serif: "Noto Serif SC", serif;
            --font-mono: "JetBrains Mono", monospace;

            --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #050505;
                --surface: #0A0A0A;
                --ink: #EDEDED;
                --ink-secondary: #888888;
                --ink-tertiary: #444444;

                --accent: #EDEDED;
                --accent-soft: rgba(255, 255, 255, 0.06);

                --line: #1F1F1F;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        body {
            font-family: var(--font-serif);
            background-color: var(--bg);
            color: var(--ink);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: background 0.6s var(--ease-out-expo);
        }

        /* --- LAYOUT UTILS --- */
        .wrapper {
            flex: 1;
            display: flex;
            position: relative;
            z-index: 10;
        }

        /* --- TYPOGRAPHY --- */
        h1 {
            font-size: 1.5rem;
            letter-spacing: 0.05em;
            font-family: var(--font-serif);
            font-weight: 400;
            color: var(--ink);
            margin-bottom: 0;
        }

        .hero-text {
            font-size: 3rem;
            line-height: 1.2;
            font-weight: 300;
            margin-bottom: 2rem;
            opacity: 0;
            animation: slideUp 0.8s var(--ease-out-expo) 0.2s forwards;
        }

        /* --- NAVIGATION --- */
        nav {
            position: absolute;
            top: 2rem;
            left: 3rem;
            right: 3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 50;
            pointer-events: none;
            /* Let clicks pass through empty nav areas */
        }

        /* Re-enable pointer events for interactive children */
        nav>* {
            pointer-events: auto;
        }


        .mode-switcher {
            display: flex;
            gap: 2rem;
        }

        .mode-btn {
            background: none;
            border: none;
            color: var(--ink-tertiary);
            font-family: var(--font-mono);
            font-size: 13px;
            cursor: pointer;
            padding-bottom: 4px;
            border-bottom: 1px solid transparent;
            transition: all 0.4s var(--ease-out-expo);
        }

        .mode-btn:hover {
            color: var(--ink);
        }

        .mode-btn.active {
            color: var(--ink);
            border-bottom-color: var(--ink);
        }

        /* --- STAGE: SPLIT VIEW --- */
        .stage {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .pane-left,
        .pane-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 6rem 3rem 3rem;
            position: relative;
            transition: transform 0.6s var(--ease-out-expo);
        }

        .pane-left {
            border-right: 1px solid var(--line);
        }

        /* --- TEXT AREA (THE CANVAS) --- */
        .input-area {
            flex: 1;
            width: 100%;
            border: none;
            background: transparent;
            font-family: var(--font-serif);
            font-size: 1.125rem;
            line-height: 1.9;
            color: var(--ink);
            resize: none;
            outline: none;
            opacity: 0.85;
            transition: opacity 0.3s;
            margin-top: 0.5rem;
        }

        .input-area::placeholder {
            color: var(--ink-tertiary);
            font-weight: 300;
            font-size: 1rem;
        }

        .input-area:focus {
            opacity: 1;
        }

        /* 面板标签 - 功能性标题 */
        .pane-label {
            font-family: var(--font-mono);
            font-size: 13px;
            font-weight: 500;
            color: var(--ink-secondary);
            letter-spacing: 0.03em;
            text-transform: uppercase;
        }

        /* 面板头部 - 统一定位 */
        .pane-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .copy-btn {
            background: none;
            border: 1px solid var(--line);
            border-radius: var(--radius-sm);
            padding: 4px 12px;
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--ink-secondary);
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0;
            pointer-events: none;
        }

        .copy-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .copy-btn:hover {
            color: var(--ink);
            border-color: var(--ink-secondary);
        }

        .copy-btn.copied {
            background-color: var(--ink);
            color: var(--bg);
            border-color: var(--ink);
        }

        /* --- FILE UPLOAD (THE VOID) --- */
        .file-drop {
            display: none;
            /* Toggled via JS */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg);
            z-index: 20;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .file-drop.active {
            display: flex;
        }

        .drop-target {
            width: 400px;
            height: 400px;
            border: 1px solid var(--line);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.6s var(--ease-out-expo);
            cursor: pointer;
            position: relative;
        }

        .drop-target::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 1px solid var(--ink);
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.6s var(--ease-out-expo);
        }

        .drop-target:hover::before,
        .drop-target.dragging::before {
            opacity: 0.1;
            transform: scale(1.1);
        }

        .drop-label {
            font-family: var(--font-mono);
            font-size: 14px;
            margin-top: 1rem;
            color: var(--ink-secondary);
        }

        .file-status {
            font-family: var(--font-serif);
            font-size: 1.25rem;
            text-align: center;
            min-height: 1.5rem;
            margin-bottom: 0.5rem;
        }

        /* --- 模糊背景层 --- */
        .doc-preview-bg {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            line-height: 2;
            color: var(--ink);
            filter: blur(2px);
            opacity: 0;
            transition: opacity 1s var(--ease-out-expo);
            pointer-events: none;
            padding: 10% 15%;
            text-align: justify;
            word-break: break-all;
            overflow: hidden;
            max-height: 100%;
            z-index: 1;
        }

        .doc-preview-bg.visible {
            opacity: 0.18;
        }

        /* --- 统计数据 --- */
        .convert-stats {
            display: flex;
            gap: 4rem;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.6s var(--ease-out-expo);
        }

        .convert-stats.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .stat-value {
            font-family: var(--font-mono);
            font-size: 1.75rem;
            font-weight: 500;
            color: var(--ink);
        }

        .stat-label {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--ink-tertiary);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        /* --- 进度环 --- */
        .progress-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .progress-ring.visible {
            opacity: 1;
        }

        .progress-ring svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .progress-ring circle {
            fill: none;
            stroke: var(--ink);
            stroke-width: 1;
            stroke-linecap: round;
            stroke-dasharray: 1256;
            stroke-dashoffset: 1256;
            transition: stroke-dashoffset 0.5s var(--ease-out-expo);
        }

        /* --- 完成状态 --- */
        .drop-target.completed {
            border-color: var(--ink);
        }

        .drop-target.completed .drop-icon {
            opacity: 0;
            transform: scale(0.8);
        }

        .success-check {
            position: absolute;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.5s var(--ease-out-expo);
            color: #22c55e;
        }

        .drop-target.completed .success-check {
            opacity: 1;
            transform: scale(1);
            animation: successBounce 0.6s var(--ease-out-expo);
        }

        @keyframes successBounce {
            0% {
                transform: scale(0);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        /* 失败状态 */
        .drop-target.error {
            border-color: #ef4444;
        }

        .drop-target.error .drop-icon {
            color: #ef4444;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        .drop-icon {
            transition: all 0.3s var(--ease-out-expo);
        }

        /* --- 结果面板 --- */
        .result-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-top: 2rem;
            z-index: 10;
            min-height: 120px;
        }

        /* --- BUTTONS --- */
        .action-btn {
            padding: 1rem 3rem;
            border-radius: 100px;
            background: var(--ink);
            color: var(--bg);
            border: none;
            font-family: var(--font-mono);
            font-size: 14px;
            letter-spacing: 0.05em;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: all 0.3s var(--ease-out-expo);
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px);
        }

        .action-btn.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        .action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        /* --- ANIMATIONS --- */
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes breathe {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.3;
            }

            50% {
                transform: scale(1.02);
                opacity: 0.6;
            }
        }

        @keyframes spin {
            from {
                transform: rotate(-90deg);
            }

            to {
                transform: rotate(270deg);
            }
        }

        .drop-target::before {
            animation: breathe 3s ease-in-out infinite;
        }

        .drop-target.processing::before {
            animation: none;
            opacity: 0;
        }

        .fade-in {
            animation: slideUp 0.6s var(--ease-out-expo) forwards;
        }

        /* --- 拖拽涟漪效果 --- */
        .drop-target.dragging::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, var(--ink) 0%, transparent 70%);
            animation: ripple 1.5s ease-out infinite;
            pointer-events: none;
        }

        @keyframes ripple {
            0% {
                transform: scale(0.8);
                opacity: 0.15;
            }

            100% {
                transform: scale(1.3);
                opacity: 0;
            }
        }

        /* --- 响应式设计 --- */
        @media (max-width: 768px) {
            nav {
                left: 1.5rem;
                right: 1.5rem;
                top: 1.5rem;
            }

            h1 {
                font-size: 12px;
            }

            .mode-btn {
                font-size: 12px;
            }

            .mode-switcher {
                gap: 1rem;
            }

            .stage {
                flex-direction: column;
            }

            .pane-left,
            .pane-right {
                flex: none;
                height: 50%;
                padding: 5rem 1.5rem 1.5rem;
                border-right: none;
                border-bottom: 1px solid var(--line);
            }

            .pane-right {
                border-bottom: none;
            }

            .pane-header {
                left: 1.5rem;
                right: 1.5rem;
                top: 4.5rem;
            }

            .input-area {
                font-size: 1rem;
            }

            .drop-target {
                width: 260px;
                height: 260px;
            }

            .result-panel {
                margin-top: 1.5rem;
            }

            .convert-stats {
                gap: 2.5rem;
            }

            .stat-value {
                font-size: 1.5rem;
            }

            .action-btn {
                padding: 0.875rem 2rem;
                font-size: 13px;
            }
        }

        /* --- 快捷键提示 --- */
        .shortcut-hint {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--ink-tertiary);
            opacity: 0.6;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .shortcut-hint {
                display: none;
            }
        }

        /* --- 设置面板 --- */
        .nav-right {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .settings-btn {
            background: none;
            border: none;
            color: var(--ink-tertiary);
            cursor: pointer;
            padding: 4px;
            transition: color 0.3s;
        }

        .settings-btn:hover {
            color: var(--ink);
        }

        .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: var(--radius-lg);
            padding: 0;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s var(--ease-out-expo);
            min-width: 320px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
        }

        .settings-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--line);
            font-family: var(--font-mono);
            font-size: 13px;
            font-weight: 500;
        }

        .settings-close {
            background: none;
            border: none;
            font-size: 20px;
            color: var(--ink-tertiary);
            cursor: pointer;
            line-height: 1;
            transition: color 0.2s;
        }

        .settings-close:hover {
            color: var(--ink);
        }

        .settings-body {
            padding: 1rem 1.5rem 1.5rem;
            max-height: 400px;
            overflow-y: auto;
        }

        .rule-toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.625rem 0;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .rule-toggle:hover {
            opacity: 0.8;
        }

        .rule-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--ink);
            cursor: pointer;
        }

        .toggle-label {
            font-family: var(--font-serif);
            font-size: 14px;
            color: var(--ink-secondary);
        }

        .toggle-label code {
            font-family: var(--font-mono);
            background: var(--accent-soft);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
        }

        .settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s;
        }

        .settings-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        @media (prefers-color-scheme: dark) {
            .settings-overlay {
                background: rgba(0, 0, 0, 0.6);
            }
        }
    </style>
</head>

<body>

    <nav>
        <h1>标点。</h1>
        <div class="nav-right">
            <button class="settings-btn" id="btn-settings" aria-label="设置">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="3" />
                    <path
                        d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" />
                </svg>
            </button>
            <div class="mode-switcher">
                <button class="mode-btn active" id="btn-text">文本</button>
                <button class="mode-btn" id="btn-file">文档</button>
            </div>
        </div>
    </nav>

    <!-- 设置面板 -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-header">
            <span>转换规则设置</span>
            <button class="settings-close" id="settings-close" aria-label="关闭设置">×</button>
        </div>
        <div class="settings-body">
            <label class="rule-toggle">
                <input type="checkbox" id="rule-comma" checked>
                <span class="toggle-label">逗号 <code>,</code> → <code>，</code></span>
            </label>
            <label class="rule-toggle">
                <input type="checkbox" id="rule-period" checked>
                <span class="toggle-label">句号 <code>.</code> → <code>。</code></span>
            </label>
            <label class="rule-toggle">
                <input type="checkbox" id="rule-colon" checked>
                <span class="toggle-label">冒号 <code>:</code> → <code>：</code></span>
            </label>
            <label class="rule-toggle">
                <input type="checkbox" id="rule-semicolon" checked>
                <span class="toggle-label">分号 <code>;</code> → <code>；</code></span>
            </label>
            <label class="rule-toggle">
                <input type="checkbox" id="rule-question" checked>
                <span class="toggle-label">问号 <code>?</code> → <code>？</code></span>
            </label>
            <label class="rule-toggle">
                <input type="checkbox" id="rule-exclaim" checked>
                <span class="toggle-label">感叹号 <code>!</code> → <code>！</code></span>
            </label>
            <label class="rule-toggle">
                <input type="checkbox" id="rule-quotes" checked>
                <span class="toggle-label">引号 <code>""</code> → <code>""</code></span>
            </label>
            <label class="rule-toggle">
                <input type="checkbox" id="rule-brackets" checked>
                <span class="toggle-label">括号 <code>()</code> → <code>（）</code></span>
            </label>
            <label class="rule-toggle">
                <input type="checkbox" id="rule-ellipsis" checked>
                <span class="toggle-label">省略号 <code>...</code> → <code>……</code></span>
            </label>
            <label class="rule-toggle">
                <input type="checkbox" id="rule-dash" checked>
                <span class="toggle-label">破折号 <code>--</code> → <code>——</code></span>
            </label>
        </div>
    </div>
    <div class="settings-overlay" id="settings-overlay"></div>

    <!-- MODE: TEXT -->
    <div class="wrapper" id="view-text">
        <div class="stage">
            <div class="pane-left">
                <div class="pane-header">
                    <span class="pane-label">输入 / 原文</span>
                </div>
                <textarea id="app-input" class="input-area" placeholder="在此粘贴文本…"></textarea>
            </div>
            <div class="pane-right">
                <div class="pane-header">
                    <span class="pane-label">输出 / 结果</span>
                    <button id="btn-copy" class="copy-btn" aria-label="复制转换结果">复制结果</button>
                </div>
                <textarea id="app-output" class="input-area" readonly placeholder="等待输入..."></textarea>
            </div>
        </div>
    </div>

    <!-- MODE: FILE -->
    <div class="file-drop" id="view-file">
        <!-- 模糊文字背景 -->
        <div class="doc-preview-bg" id="preview-bg"></div>

        <div class="drop-target" id="drop-zone" role="button" aria-label="点击或拖拽上传文档" tabindex="0">
            <!-- 进度环 -->
            <div class="progress-ring" id="progress-ring">
                <svg viewBox="0 0 400 400">
                    <circle cx="200" cy="200" r="199" id="progress-circle"></circle>
                </svg>
            </div>

            <!-- 上传图标 -->
            <div class="drop-icon">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M12 5V19M12 5L6 11M12 5L18 11" stroke-linecap="square" />
                </svg>
            </div>

            <!-- 成功图标 -->
            <div class="success-check">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M5 12l5 5L20 7" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
            </div>

            <div class="drop-label" id="drop-label">拖拽或点击上传</div>
            <input type="file" id="file-input" hidden accept=".docx,.txt,.md" multiple>
        </div>

        <!-- 结果面板 -->
        <div class="result-panel" id="result-panel">
            <div class="file-status" id="file-status" role="status" aria-live="polite"></div>

            <!-- 统计数据 -->
            <div class="convert-stats" id="convert-stats">
                <div class="stat-item">
                    <span class="stat-value" id="stat-punct">0</span>
                    <span class="stat-label">标点转换</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="stat-para">0</span>
                    <span class="stat-label">段落处理</span>
                </div>
            </div>

            <button class="action-btn" id="dl-btn" aria-label="下载处理后的文档">下载处理后的文档</button>
        </div>
    </div>

    <!-- 快捷键提示 -->
    <div class="shortcut-hint" id="shortcut-hint">
        Ctrl+Shift+C 复制结果
    </div>

    <script>
        /**
         * CORE LOGIC: THE ENGINE
         * Supports dynamic rule configuration
         */
        const PUNCT_MAP = {
            ',': '，', '.': '。', ':': '：', ';': '；',
            '?': '？', '!': '！', '(': '（', ')': '）'
        };

        // 规则配置（动态）
        const ruleConfig = {
            comma: true, period: true, colon: true, semicolon: true,
            question: true, exclaim: true, quotes: true, brackets: true,
            ellipsis: true, dash: true
        };

        // 从localStorage加载规则
        function loadRules() {
            const saved = localStorage.getItem('punctuation-rules');
            if (saved) Object.assign(ruleConfig, JSON.parse(saved));
        }

        // 保存规则到localStorage
        function saveRules() {
            localStorage.setItem('punctuation-rules', JSON.stringify(ruleConfig));
        }

        loadRules();

        function smartConvert(text) {
            if (!text) return "";

            // 省略号转换
            if (ruleConfig.ellipsis) {
                text = text.replace(/([\u4e00-\u9fa5])\.{3}/g, (m, cn) => cn + '……');
                text = text.replace(/\.{3}([\u4e00-\u9fa5])/g, (m, cn) => '……' + cn);
            }

            // 破折号转换
            if (ruleConfig.dash) {
                text = text.replace(/([\u4e00-\u9fa5])--/g, (m, cn) => cn + '——');
                text = text.replace(/--([\u4e00-\u9fa5])/g, (m, cn) => '——' + cn);
            }

            // 基础标点转换
            const activeMap = {};
            if (ruleConfig.comma) activeMap[','] = '，';
            if (ruleConfig.period) activeMap['.'] = '。';
            if (ruleConfig.colon) activeMap[':'] = '：';
            if (ruleConfig.semicolon) activeMap[';'] = '；';
            if (ruleConfig.question) activeMap['?'] = '？';
            if (ruleConfig.exclaim) activeMap['!'] = '！';

            const keys = Object.keys(activeMap);
            if (keys.length) {
                const pat = keys.map(p => '\\' + p).join('');
                text = text.replace(new RegExp(`([\\u4e00-\\u9fa5])\\s*([${pat}])`, 'g'),
                    (m, cn, p) => cn + (activeMap[p] || p));
                text = text.replace(new RegExp(`([${pat}])\\s*([\\u4e00-\\u9fa5])`, 'g'),
                    (m, p, cn) => (activeMap[p] || p) + cn);
            }

            // 括号
            if (ruleConfig.brackets) {
                text = text.replace(/\(\s*([\u4e00-\u9fa5])/g, (m, cn) => '（' + cn);
                text = text.replace(/([\u4e00-\u9fa5])\s*\)/g, (m, cn) => cn + '）');
            }

            // 引号
            if (ruleConfig.quotes) {
                text = processQuotesStateful(text, '"', '\u201c', '\u201d');
                text = processQuotesStateful(text, "'", '\u2018', '\u2019');
            }

            return text;
        }

        // Stateful quote processor for plain text
        function processQuotesStateful(text, quote, open, close) {
            let result = "";
            let isOpen = false;
            const isHan = (char) => /[\u4e00-\u9fa5]/.test(char);

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (char === quote) {
                    const prev = text[i - 1] || '';
                    const next = text[i + 1] || '';
                    const isChinese = isHan(prev) || isHan(next);

                    if (isOpen) {
                        result += close;
                        isOpen = false;
                    } else if (isChinese) {
                        result += open;
                        isOpen = true;
                    } else {
                        result += quote;
                    }
                } else {
                    result += char;
                }
            }
            return result;
        }

        /* --- INTERACTION --- */
        const views = {
            text: document.getElementById('view-text'),
            file: document.getElementById('view-file')
        };
        const btns = {
            text: document.getElementById('btn-text'),
            file: document.getElementById('btn-file')
        };

        function switchView(mode) {
            // Toggle view visibility
            if (mode === 'text') {
                views.text.style.display = 'flex';
                views.file.classList.remove('active');
            } else {
                views.text.style.display = 'none';
                views.file.classList.add('active');
            }

            // Toggle nav state
            btns.text.classList.toggle('active', mode === 'text');
            btns.file.classList.toggle('active', mode === 'file');

            // 更新快捷键提示
            const hint = document.getElementById('shortcut-hint');
            hint.textContent = mode === 'text' ? 'Ctrl+Shift+C 复制结果' : '';

            // 保存用户偏好
            localStorage.setItem('punctuation-mode', mode);
        }

        btns.text.onclick = () => switchView('text');
        btns.file.onclick = () => switchView('file');

        // 启动时恢复用户偏好
        const savedMode = localStorage.getItem('punctuation-mode');
        if (savedMode === 'file') {
            switchView('file');
        }

        /* --- COPY FUNCTIONALITY --- */
        const copyBtn = document.getElementById('btn-copy');
        const outputArea = document.getElementById('app-output');

        // Auto-show/hide copy button based on content
        function updateCopyState() {
            if (outputArea.value.trim().length > 0) {
                copyBtn.classList.add('visible');
            } else {
                copyBtn.classList.remove('visible');
            }
        }

        // Copy Action
        copyBtn.onclick = async () => {
            if (!outputArea.value) return;
            try {
                await navigator.clipboard.writeText(outputArea.value);
                const originalText = copyBtn.textContent;
                copyBtn.textContent = "已复制";
                copyBtn.classList.add('copied');

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.classList.remove('copied');
                }, 1500);
            } catch (err) {
                console.error('Failed to copy', err);
            }
        };

        /* --- TEXT MODE --- */
        const input = document.getElementById('app-input');
        // const output = document.getElementById('app-output'); // outputArea is already defined above

        input.addEventListener('input', () => {
            outputArea.value = smartConvert(input.value);
            updateCopyState();
        });

        /* --- FILE MODE --- */
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const status = document.getElementById('file-status');
        const dlBtn = document.getElementById('dl-btn');
        const previewBg = document.getElementById('preview-bg');
        const progressRing = document.getElementById('progress-ring');
        const progressCircle = document.getElementById('progress-circle');
        const convertStats = document.getElementById('convert-stats');
        const statPunct = document.getElementById('stat-punct');
        const statPara = document.getElementById('stat-para');
        const dropLabel = document.getElementById('drop-label');

        let dlBlob = null;
        let dlName = "";

        // 重置UI状态
        function resetFileUI() {
            dropZone.classList.remove('processing', 'completed');
            previewBg.classList.remove('visible');
            previewBg.textContent = '';
            progressRing.classList.remove('visible');
            progressCircle.style.strokeDashoffset = '1256';
            convertStats.classList.remove('visible');
            dlBtn.classList.remove('visible');
            status.textContent = '';
            dropLabel.textContent = '拖拽或点击上传';
            statPunct.textContent = '0';
            statPara.textContent = '0';
        }

        // 更新进度环
        function updateProgress(percent) {
            const circumference = 1256; // 2 * PI * 199
            const offset = circumference - (percent / 100) * circumference;
            progressCircle.style.strokeDashoffset = offset;
        }

        // 计数器动画
        function animateCount(el, target, duration = 800) {
            const start = 0;
            const startTime = performance.now();

            function update(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                // easeOutCubic
                const eased = 1 - Math.pow(1 - progress, 3);
                el.textContent = Math.round(start + (target - start) * eased);
                if (progress < 1) requestAnimationFrame(update);
            }
            requestAnimationFrame(update);
        }

        // 进度阶段
        const PROGRESS_STAGES = {
            10: '正在读取文件...',
            20: '正在解析文档结构...',
            40: '正在分析中文语境...',
            70: '正在转换标点符号...',
            90: '正在生成新文档...',
            100: '处理完成！'
        };

        function updateProgressWithText(percent) {
            updateProgress(percent);
            if (PROGRESS_STAGES[percent]) {
                status.textContent = PROGRESS_STAGES[percent];
            }
        }

        dropZone.onclick = () => {
            if (dropZone.classList.contains('completed')) {
                resetFileUI();
            }
            fileInput.click();
        };

        // Drag effects
        dropZone.ondragover = (e) => { e.preventDefault(); dropZone.classList.add('dragging'); };
        dropZone.ondragleave = () => dropZone.classList.remove('dragging');
        dropZone.ondrop = (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragging');
            if (e.dataTransfer.files.length > 1) {
                handleMultipleFiles(e.dataTransfer.files);
            } else if (e.dataTransfer.files.length === 1) {
                handleFile(e.dataTransfer.files[0]);
            }
        };
        fileInput.onchange = (e) => {
            if (e.target.files.length > 1) {
                handleMultipleFiles(e.target.files);
            } else if (e.target.files.length === 1) {
                handleFile(e.target.files[0]);
            }
        };

        // 批量文件处理
        async function handleMultipleFiles(files) {
            resetFileUI();
            dropZone.classList.add('processing');
            progressRing.classList.add('visible');
            status.style.opacity = 1;
            dropLabel.textContent = '';

            const zip = new JSZip();
            let totalPunct = 0, totalPara = 0;

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                status.textContent = `处理中 (${i + 1}/${files.length}): ${file.name}`;
                updateProgress((i / files.length) * 80 + 10);

                try {
                    const ext = file.name.split('.').pop().toLowerCase();
                    let blob, counts;

                    if (ext === 'txt' || ext === 'md') {
                        const text = await file.text();
                        const converted = smartConvert(text);
                        blob = new Blob([converted], { type: 'text/plain' });
                        counts = { punct: countChanges(text, converted), para: (text.match(/\n/g) || []).length + 1 };
                    } else {
                        // DOCX处理 - 使用段落级处理方式（与单文件一致）
                        const docZip = await JSZip.loadAsync(file);
                        let pCount = 0, paraCount = 0;

                        for (const path of Object.keys(docZip.files)) {
                            if (path.endsWith('.xml')) {
                                const content = await docZip.file(path).async('string');
                                const parser = new DOMParser();
                                const xmlDoc = parser.parseFromString(content, 'text/xml');
                                const paragraphs = xmlDoc.getElementsByTagName('w:p');
                                let hasChanges = false;

                                for (let pi = 0; pi < paragraphs.length; pi++) {
                                    const p = paragraphs[pi];
                                    const textNodes = p.getElementsByTagName('w:t');
                                    if (!textNodes.length) continue;

                                    // 收集整个段落的文本和映射
                                    let fullText = '';
                                    const mapping = [];
                                    for (let t = 0; t < textNodes.length; t++) {
                                        const node = textNodes[t];
                                        const txt = node.textContent;
                                        for (let c = 0; c < txt.length; c++) {
                                            mapping.push({ node, idx: c });
                                        }
                                        fullText += txt;
                                    }

                                    if (!fullText.trim()) continue;
                                    paraCount++;

                                    // 转换整个段落文本
                                    const converted = smartConvert(fullText);

                                    // 如果有变化，映射回各节点
                                    if (converted !== fullText && converted.length === fullText.length) {
                                        for (let i = 0; i < converted.length; i++) {
                                            if (converted[i] !== fullText[i]) {
                                                const { node, idx } = mapping[i];
                                                const arr = node.textContent.split('');
                                                arr[idx] = converted[i];
                                                node.textContent = arr.join('');
                                                pCount++;
                                                hasChanges = true;
                                            }
                                        }
                                    }
                                }

                                if (hasChanges) {
                                    docZip.file(path, new XMLSerializer().serializeToString(xmlDoc));
                                }
                            }
                        }
                        blob = await docZip.generateAsync({ type: 'blob' });
                        counts = { punct: pCount, para: paraCount };
                    }

                    zip.file('已转换_' + file.name, blob);
                    totalPunct += counts.punct;
                    totalPara += counts.para;
                } catch (err) {
                    console.error(`处理 ${file.name} 失败:`, err);
                }
            }

            updateProgress(90);
            status.textContent = '正在打包...';

            dlBlob = await zip.generateAsync({ type: 'blob' });
            dlName = `批量转换_${files.length}个文件.zip`;

            updateProgress(100);
            showCompletedState(`${files.length} 个文件`, '', totalPunct, totalPara);
        }

        function countChanges(original, converted) {
            let count = 0;
            for (let i = 0; i < Math.min(original.length, converted.length); i++) {
                if (original[i] !== converted[i]) count++;
            }
            return count;
        }

        async function handleFile(file) {
            // 重置并开始处理
            resetFileUI();
            dropZone.classList.add('processing');
            progressRing.classList.add('visible');
            status.textContent = "正在解析文档结构...";
            status.style.opacity = 1;
            dropLabel.textContent = '';

            let totalPunctChanges = 0;
            let totalParaProcessed = 0;
            let previewText = '';

            // 获取文件扩展名
            const ext = file.name.split('.').pop().toLowerCase();

            try {
                updateProgressWithText(10);

                // TXT 或 MD 文件处理
                if (ext === 'txt' || ext === 'md') {
                    updateProgressWithText(20);
                    const text = await file.text();
                    const originalText = text;

                    updateProgressWithText(40);
                    const convertedText = smartConvert(text);

                    // 统计变化
                    for (let i = 0; i < Math.min(originalText.length, convertedText.length); i++) {
                        if (originalText[i] !== convertedText[i]) {
                            totalPunctChanges++;
                        }
                    }
                    totalParaProcessed = (text.match(/\n/g) || []).length + 1;
                    previewText = convertedText.slice(0, 400);

                    updateProgressWithText(70);
                    updateProgressWithText(90);

                    // 生成下载文件
                    dlBlob = new Blob([convertedText], { type: 'text/plain;charset=utf-8' });
                    dlName = "已转换_" + file.name;

                    updateProgressWithText(100);

                    // 显示完成状态
                    showCompletedState(file.name, previewText, totalPunctChanges, totalParaProcessed);
                    return;
                }

                // DOCX 文件处理
                updateProgressWithText(10);
                const zip = await JSZip.loadAsync(file);
                const xmlFiles = [];
                zip.forEach((path) => { if (path.endsWith('.xml')) xmlFiles.push(path); });

                updateProgressWithText(20);

                // DOM Based logic
                for (let fileIdx = 0; fileIdx < xmlFiles.length; fileIdx++) {
                    const path = xmlFiles[fileIdx];
                    const content = await zip.file(path).async("string");
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(content, "text/xml");
                    const paragraphs = xmlDoc.getElementsByTagName("w:p");

                    let hasChanges = false;

                    for (let i = 0; i < paragraphs.length; i++) {
                        const p = paragraphs[i];
                        const textNodes = p.getElementsByTagName("w:t");
                        if (!textNodes.length) continue;

                        let fullText = "";
                        const mapping = [];
                        for (let t = 0; t < textNodes.length; t++) {
                            const node = textNodes[t];
                            const txt = node.textContent;
                            for (let c = 0; c < txt.length; c++) mapping.push({ node, idx: c });
                            fullText += txt;
                        }

                        // 提取预览文字（仅从document.xml）
                        if (path.includes('document.xml') && previewText.length < 400) {
                            previewText += fullText + ' ';
                        }

                        // 统计段落
                        if (fullText.trim().length > 0) {
                            totalParaProcessed++;
                        }

                        // Simple Punctuation
                        const patterns = [
                            { r: /([\u4e00-\u9fa5])\s*([,.:;?!])/g, off: 1, map: PUNCT_MAP },
                            { r: /([,.:;?!])\s*([\u4e00-\u9fa5])/g, off: 0, map: PUNCT_MAP },
                            { r: /\(\s*([\u4e00-\u9fa5])/g, off: 0, rep: '（' },
                            { r: /([\u4e00-\u9fa5])\s*\)/g, off: 1, rep: '）' }
                        ];

                        patterns.forEach(pat => {
                            let m; pat.r.lastIndex = 0;
                            while (m = pat.r.exec(fullText)) {
                                const targetIdx = pat.off === 0 ? m.index : (m.index + m[0].length - 1);
                                const rep = pat.map ? pat.map[pat.off === 0 ? m[1] : m[2]] : pat.rep;
                                modify(targetIdx, rep, mapping);
                                hasChanges = true;
                                totalPunctChanges++;
                            }
                        });

                        // Quotes
                        const quoteChanges1 = processQuoteInPlace(fullText, '"', '\u201c', '\u201d', mapping);
                        const quoteChanges2 = processQuoteInPlace(fullText, "'", '\u2018', '\u2019', mapping);
                        if (quoteChanges1) { hasChanges = true; totalPunctChanges += quoteChanges1; }
                        if (quoteChanges2) { hasChanges = true; totalPunctChanges += quoteChanges2; }
                    }

                    if (hasChanges) {
                        zip.file(path, new XMLSerializer().serializeToString(xmlDoc));
                    }

                    // 更新进度
                    const progress = 40 + Math.round((fileIdx + 1) / xmlFiles.length * 30);
                    updateProgressWithText(progress >= 70 ? 70 : progress);
                }

                updateProgressWithText(90);

                dlBlob = await zip.generateAsync({ type: "blob" });
                dlName = "已转换_" + file.name;

                updateProgressWithText(100);

                // 显示完成状态
                showCompletedState(file.name, previewText, totalPunctChanges, totalParaProcessed);

            } catch (e) {
                console.error(e);
                dropZone.classList.remove('processing');
                dropZone.classList.add('error');
                progressRing.classList.remove('visible');
                status.textContent = "处理失败：文档结构不兼容";

                // 3秒后重置错误状态
                setTimeout(() => {
                    dropZone.classList.remove('error');
                    resetFileUI();
                }, 3000);
            }
        }

        // 显示完成状态的辅助函数
        function showCompletedState(fileName, previewText, punctCount, paraCount) {
            // 显示预览背景
            if (previewText && previewText.trim()) {
                previewBg.textContent = previewText.trim().slice(0, 400);
                setTimeout(() => previewBg.classList.add('visible'), 100);
            }

            // 完成状态
            dropZone.classList.remove('processing');
            dropZone.classList.add('completed');
            progressRing.classList.remove('visible');

            status.textContent = fileName;

            // 显示统计数据（带动画）
            setTimeout(() => {
                convertStats.classList.add('visible');
                animateCount(statPunct, punctCount);
                animateCount(statPara, paraCount);
            }, 200);

            dlBtn.textContent = "下载处理后的文档";
            setTimeout(() => dlBtn.classList.add('visible'), 400);
        }

        function modify(idx, char, map) {
            if (idx >= 0 && idx < map.length) {
                const { node, idx: nIdx } = map[idx];
                const arr = node.textContent.split('');
                if (arr[nIdx] !== char) {
                    arr[nIdx] = char;
                    node.textContent = arr.join('');
                }
            }
        }

        function processQuoteInPlace(text, quote, open, close, map) {
            let changeCount = 0;
            let isOpen = false;
            const isHan = (c) => /[\u4e00-\u9fa5]/.test(c);

            for (let i = 0; i < text.length; i++) {
                if (text[i] === quote) {
                    const prev = text[i - 1] || '';
                    const next = text[i + 1] || '';
                    const cnCtx = isHan(prev) || isHan(next);

                    if (isOpen) {
                        modify(i, close, map);
                        isOpen = false;
                        changeCount++;
                    } else if (cnCtx) {
                        modify(i, open, map);
                        isOpen = true;
                        changeCount++;
                    }
                }
            }
            return changeCount;
        }

        dlBtn.onclick = () => saveAs(dlBlob, dlName);

        /* --- 快捷键支持 --- */
        document.addEventListener('keydown', (e) => {
            // Ctrl+Shift+C: 复制结果
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                if (outputArea.value) {
                    copyBtn.click();
                }
            }

            // Escape: 聚焦输入框
            if (e.key === 'Escape') {
                input.focus();
            }
        });

        // 更新快捷键提示根据模式
        const shortcutHint = document.getElementById('shortcut-hint');
        function updateShortcutHint(mode) {
            shortcutHint.textContent = mode === 'text' ? 'Ctrl+Shift+C 复制结果' : '';
        }

        /* --- 设置面板 --- */
        const settingsBtn = document.getElementById('btn-settings');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsClose = document.getElementById('settings-close');
        const settingsOverlay = document.getElementById('settings-overlay');

        function openSettings() {
            settingsPanel.classList.add('active');
            settingsOverlay.classList.add('active');
            syncSettingsUI();
        }

        function closeSettings() {
            settingsPanel.classList.remove('active');
            settingsOverlay.classList.remove('active');
        }

        // 同步设置UI与ruleConfig
        function syncSettingsUI() {
            document.getElementById('rule-comma').checked = ruleConfig.comma;
            document.getElementById('rule-period').checked = ruleConfig.period;
            document.getElementById('rule-colon').checked = ruleConfig.colon;
            document.getElementById('rule-semicolon').checked = ruleConfig.semicolon;
            document.getElementById('rule-question').checked = ruleConfig.question;
            document.getElementById('rule-exclaim').checked = ruleConfig.exclaim;
            document.getElementById('rule-quotes').checked = ruleConfig.quotes;
            document.getElementById('rule-brackets').checked = ruleConfig.brackets;
            document.getElementById('rule-ellipsis').checked = ruleConfig.ellipsis;
            document.getElementById('rule-dash').checked = ruleConfig.dash;
        }

        // 规则开关事件
        const ruleMap = {
            'rule-comma': 'comma', 'rule-period': 'period', 'rule-colon': 'colon',
            'rule-semicolon': 'semicolon', 'rule-question': 'question', 'rule-exclaim': 'exclaim',
            'rule-quotes': 'quotes', 'rule-brackets': 'brackets', 'rule-ellipsis': 'ellipsis',
            'rule-dash': 'dash'
        };

        Object.keys(ruleMap).forEach(id => {
            document.getElementById(id).addEventListener('change', (e) => {
                ruleConfig[ruleMap[id]] = e.target.checked;
                saveRules();
                // 实时更新文本模式输出
                if (input.value) {
                    outputArea.value = smartConvert(input.value);
                }
            });
        });

        settingsBtn.onclick = openSettings;
        settingsClose.onclick = closeSettings;
        settingsOverlay.onclick = closeSettings;

        // Escape关闭设置面板
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && settingsPanel.classList.contains('active')) {
                closeSettings();
                e.stopPropagation();
            }
        });

    </script>
</body>

</html>